# About the project

This application is a visualizing tool for pathfinding and maze-generating algorithms built using Python3 with pygame.

Inspired by: https://youtu.be/n4t_-NjY_Sg?t=183

# Guide

### Required setup

- Make sure you have installed [Python 3](https://www.python.org/downloads/) and [pygame](https://youtu.be/Y4Jn0UCqY28?t=163).
- Download the repository, navigate to its directory and run with "python main.py" or "python3 main.py".

### Basic usage

- On the top right you can see the node color legend.
- Use LEFT MOUSE BUTTON to select nodes and click buttons (the first click will select the start node and the second the end node).
- Use RIGHT MOUSE BUTTON to unselect nodes.
- To select a pathfinding algorithm click on it; selected button will change its color.
- To run the algorithm click "RUN" (green button).
- While an algorithm is running you can click "FINISH" (blue button) that appeared in place of "RUN" to skip animations of the algorithm"
- If you want to generate a maze, click any of the light green buttons ("Prim's, "Division", "Backtrack", "Random").
- After running an algorithm you can clear the grid (click "CLEAR", yellow button) and you will keep your start and end nodes, as well as any barriers.
- You can also reset the grid (click "RESET", red button), to remove everything.
- To exit the program simply click "X" or use the same shortcut as for any other window on your machine.

### Additional info
- You can click "GRID OFF" button to toggle gridlines and click again on "GRID ON" to turn them off.
- You can change the size of the graph by clicking: "S" (small), "M" (medium) and "L" (large) buttons; selected button will change its color.
- You can change the animation speed by clicking: "S" (slow), "N" (normal) and "F" (fast) buttons; selected button will change its color.
- You can resize the window as any other on your machine.
- Current settings will be saved to "settings.txt" file and loaded in next time you run the app.

# About the algorithms

## Pathfinding algorithms

**BFS**: **B**readth-**F**irst **S**earch explores all nodes at the present depth (neighbors) and then moves on to next depth level (neighbors of neighbors ...); BFS **guarantees** the shortest path (good pathfinding algorithm).

**DFS**: **D**epth-**F**irst **S**earch explores nodes as far as possible (until reaching max depth) before backtracking; DFS **does not guarantee** the shortest path (bad pathfinding algorithm).

**Dijkstra's algorithm**: Dijkstra's is a **weighted** algorithm that, when no weights are added, works similarly to BFS; Dijkstra's algorithm **guarantees** the shortest path (good pathfinding algorithm).

**A\***: A* is a very efficient pathfinding algorithm that uses heuristic functions to guide its search (unlike previously described algorithms it is aware of the position of the end node), its efficiency comes at a cost of memory space; A* **guarantees** the shortest path, while being more time efficient that other algorithms (very good pathfinding algorithm).

## Maze-generating algorithms

**Prim's algorithm**: Prim's is a greedy algorithm that creates a minimal spanning tree (MST). Mazes generated by this algorithm are "perfect" - every node within it is reachable and there is only a single path from one node in the maze to any other. It is implemented as a passage (free node) adder (starts with graph full of barriers)

**Recursive Division**: Recursive Division algorithm divides the maze in half with a wall with a single passage until there is no more room for new walls. Mazes generated by this algorithm are "perfect" - every node within it is reachable and there is only a single path from one node in the maze to any other. It is implemented as a wall adder (starts with graph full of passages (free nodes)).

**Recursive Backtracking**: Recursive Backtracker generates mazes by utilizing randomized depth-first search after reaching the max depth, it backtracks adding more dead ends. It is implemented as a passage (free node) adder (starts with graph full of barriers)

**Random**: Purely randomized generation with 1/3 chance to turn a free node into a barrier. It doesn't generate a perfect maze and may even create one that is unsolvable.
